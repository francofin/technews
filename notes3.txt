 So we need to create a third table, for the sole purpose of connecting the data between two other tables with their primary keys.
  This is known as a through table

Notice the syntax. We instruct the application that the User and Post models will be connected, but in this case through the Vote model.
 We state what we want the foreign key to be in Vote, which aligns with the fields we set up in the model. 
 also stipulate that the name of the Vote model should be displayed as voted_posts when queried on, making it a little more informative.

If we want to see the total number of votes on a post, we need to directly connect the Post and Vote models.

When we vote on a post, we're technically updating that post's data. This means that we should create a PUT route for updating a post.

But Sequelize also offers something called model methods. 
Let's say we've written a complicated query with Sequelize that involved the combination of a few other Sequelize methods. 
Sequelize model methods allow us to give that complicated set of functionality its own name.

Here, we're using JavaScript's built-in static keyword to indicate that the upvote method is one that's 
based on the Post model and not an instance method like we used earlier with the User model. 
This exemplifies Sequelize's heavy usage of object-oriented principles and concepts.

MVC is an architectural pattern that
 structures a codebase as three distinct sections according to a software design philosophy known as separation of concerns.
 dynamically generate HTML using Handlebars.js, a popular templating engine, to form the View layer.
 And you’ll use Express.js to create the Controller.
 As the intermediary layer that connects the View and the Model, the Controller handles input from the user, 
 interacts with the Model to create, read, update, or delete data, and then returns those query results to the user via the View layer.

 Handlebars.js (Links to an external site.) is a logicless templating language that keeps the View and the code separate and 
 compiles templates into JavaScript functions. It’s an extension to the Mustache templating language. 
 Although there is a standard Handlebars npm package (Links to an external site.),
  you’ll use the Express Handlebars package (Links to an external site.) as the View engine for your Express.js applications.

The express-session package (Links to an external site.) is an Express.js middleware that uses sessions, 
a mechanism that helps applications to determine whether multiple requests came from the same client. 
Developers may assign every user a unique session so that their application can store the user state, and thus authenticate users.

The connect-session-sequelize package (Links to an external site.) provides applications with a scalable store for sessions. 
The express-session package’s default server-side session storage, MemoryStore, is purposely not designed for a production environment,
 will leak memory under most conditions, doesn’t scale past a single process, and is only meant for debugging and developing. 
The connect-session-sequelize package resolves these issues and is compatible with the Sequelize ORM.

The express.static() method is a built-in Express.js middleware function that can take all of the contents
 of a folder and serve them as static assets.
 This is useful for front-end specific files like images, style sheets, and JavaScript files.

 In this case, we want to render the homepage.handlebars template (the .handlebars extension is implied).
  This template was light on content; it only included a single <div>.
  Handlebars.js will automatically feed that into the main.handlebars template, however, and respond with a complete HTML file.